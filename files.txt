[FILE_START]README.md
# git-repo-to-json

[FILE_END]README.md

[FILE_START]package.json
{
  "name": "git-repo-parser",
  "version": "2.0.7",
  "description": "A tool to scrape all files from a GitHub repository and turn it into a JSON file",
  "bin": {
    "git-repo-to-json": "dist/clijson.js",
    "git-repo-to-text": "dist/clitext.js"
  },
  "files": [
    "dist"
  ],
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/cli.js"
  },
  "keywords": [
    "github",
    "scraper",
    "json"
  ],
  "author": "arnab2001",
  "license": "MIT",
  "dependencies": {
    "simple-git": "^2.41.0"
  },
  "devDependencies": {
    "@types/node": "^18.11.19",
    "typescript": "^4.9.4"
  }
}
[FILE_END]package.json

[DIR_START]src
[FILE_START]src/clijson.ts
#!/usr/bin/env node

import { scrapeRepositoryToJson } from "./scraper";
import * as fs from 'fs';

async function main() {
    const repoUrl = process.argv[2]; // Get the repository URL from command line arguments

    if (!repoUrl) {
        console.error('Please provide a GitHub repository URL.');
        process.exit(1);
    }

    // Scrape the repository and get the result
    const result = await scrapeRepositoryToJson(repoUrl);
    const jsonResult = JSON.stringify(result, null, 2);

    // Write the JSON to a file
    fs.writeFileSync('files.json', jsonResult);
    console.log('File list has been saved to files.json');
}

main().catch(err => console.error(err));
[FILE_END]src/clijson.ts

[FILE_START]src/clitext.ts
#!/usr/bin/env node

import { scrapeRepositoryToPlainText } from "./scraper";
import * as fs from 'fs';

async function main() {
    const repoUrl = process.argv[2]; // Get the repository URL from command line arguments

    if (!repoUrl) {
        console.error('Please provide a GitHub repository URL.');
        process.exit(1);
    }

    // Scrape the repository and get the result
    const result = await scrapeRepositoryToPlainText(repoUrl);

    // Write the JSON to a file
    fs.writeFileSync('files.txt', result);
    console.log('File list has been saved to files.text');
}

main().catch(err => console.error(err));
[FILE_END]src/clitext.ts

[FILE_START]src/index.ts
import { scrapeRepositoryToJson, scrapeRepositoryToPlainText } from './scraper';

export { scrapeRepositoryToJson, scrapeRepositoryToPlainText };

[FILE_END]src/index.ts

[FILE_START]src/scraper.ts
import * as fs from 'fs';
import * as path from 'path';
import simpleGit from 'simple-git';

export interface FileData {
    name: string;
    path: string;
    type: 'file' | 'directory';
    children?: FileData[];
    content?: string;
}

async function cloneRepository(repoUrl: string, clonePath: string) {
    const git = simpleGit();
    await git.clone(repoUrl, clonePath);
    console.log(`Repository cloned to ${clonePath}`);
}

function shouldIgnoreFile(fileName: string): boolean {
    const lowerCaseFileName = fileName.toLowerCase();
    return (
        lowerCaseFileName === 'package-lock.json' ||
        lowerCaseFileName.endsWith('.pdf') ||
        lowerCaseFileName.endsWith('.png') ||
        lowerCaseFileName.endsWith('.jpg') ||
        lowerCaseFileName.endsWith('.jpeg') ||
        lowerCaseFileName.endsWith('.gif') ||
        lowerCaseFileName.endsWith('.ico') ||
        lowerCaseFileName.endsWith('.svg') ||
        lowerCaseFileName.endsWith('.woff') ||
        lowerCaseFileName.endsWith('.woff2') ||
        lowerCaseFileName.endsWith('.eot') ||
        lowerCaseFileName.endsWith('.ttf') ||
        lowerCaseFileName.endsWith('.otf') ||
        lowerCaseFileName.endsWith('.mp4') ||
        lowerCaseFileName.endsWith('.avi') ||
        lowerCaseFileName.endsWith('.webm') ||
        lowerCaseFileName.endsWith('.mov') ||
        lowerCaseFileName.endsWith('.mp3') ||
        lowerCaseFileName.endsWith('.wav') ||
        lowerCaseFileName.endsWith('.flac') ||
        lowerCaseFileName.endsWith('.ogg') ||
        lowerCaseFileName.endsWith('.webp') ||
        lowerCaseFileName.startsWith('package-lock') ||
        lowerCaseFileName.startsWith('yarn-lock') ||
        lowerCaseFileName.startsWith('npm-debug') ||
        lowerCaseFileName.startsWith('yarn-debug') ||
        lowerCaseFileName.startsWith('yarn-error') ||
        lowerCaseFileName.startsWith('tsconfig') ||
        lowerCaseFileName.startsWith('jest.config') 

        // Add more extensions as needed
    );
}

function scrapeDirectoryToJson(dir: string, ignorePatterns: string[] = []): FileData[] {
    const files = fs.readdirSync(dir);
    return files.filter(file => {
        const filePath = path.join(dir, file);
        return (
            !ignorePatterns.some(pattern => filePath.includes(pattern)) &&
            !shouldIgnoreFile(file)
        );
    }).map(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);

        if (stat.isDirectory()) {
            // Ignore the .git directory
            if (file === '.git') {
                return null;
            }
            return {
                name: file,
                path: filePath,
                type: 'directory',
                children: scrapeDirectoryToJson(filePath, ignorePatterns)
            };
        } else {
            const content = fs.readFileSync(filePath, 'utf-8');
            return {
                name: file,
                path: filePath,
                type: 'file',
                content: content
            };
        }
    }).filter(item => item !== null) as FileData[];
}

function scrapeDirectoryToPlainText(dir: string, ignorePatterns: string[] = [], prefix: string = ''): string {
    let result = '';

    const files = fs.readdirSync(dir);
    files.forEach(file => {
        const filePath = path.join(dir, file);

        if (ignorePatterns.some(pattern => filePath.includes(pattern)) || shouldIgnoreFile(file)) {
            return;
        }

        const stat = fs.statSync(filePath);

        if (stat.isDirectory()) {
            // Ignore the .git directory
            if (file === '.git') {
                return;
            }
            // Mark the start of a directory
            result += `[DIR_START]${path.join(prefix, file)}\n`;
            result += scrapeDirectoryToPlainText(filePath, ignorePatterns, path.join(prefix, file));
            // Mark the end of a directory
            result += `[DIR_END]${path.join(prefix, file)}\n\n`;
        } else {
            // Mark the start of a file
            result += `[FILE_START]${path.join(prefix, file)}\n`;
            const content = fs.readFileSync(filePath, 'utf-8');
            result += content;
            // Mark the end of a file
            result += `\n[FILE_END]${path.join(prefix, file)}\n\n`;
        }
    });

    return result;
}

export async function scrapeRepositoryToJson(repoUrl: string): Promise<FileData[]> {
    const repoName = repoUrl.split('/').pop()?.replace('.git', '');
    if (!repoName) {
        throw new Error('Invalid repository URL');
    }
    const clonePath = `./${repoName}`; // Directory where the repository will be cloned

    // Clone the repository
    await cloneRepository(repoUrl, clonePath);

    // Scrape the cloned repository directory
    const ignorePatterns = ['.git'];
    const result = scrapeDirectoryToJson(clonePath, ignorePatterns);

    // Clean up the cloned repository
    fs.rmdirSync(clonePath, { recursive: true });
    console.log('Cloned repository directory removed');

    return result;
}

export async function scrapeRepositoryToPlainText(repoUrl: string): Promise<string> {
    const repoName = repoUrl.split('/').pop()?.replace('.git', '');
    if (!repoName) {
        throw new Error('Invalid repository URL');
    }
    const clonePath = `./${repoName}`; // Directory where the repository will be cloned

    // Clone the repository
    await cloneRepository(repoUrl, clonePath);

    // Scrape the cloned repository directory
    const ignorePatterns = ['.git'];
    const result = scrapeDirectoryToPlainText(clonePath, ignorePatterns);

    // Clean up the cloned repository
    fs.rmdirSync(clonePath, { recursive: true });
    console.log('Cloned repository directory removed');

    return result;
}

[FILE_END]src/scraper.ts

[DIR_END]src

